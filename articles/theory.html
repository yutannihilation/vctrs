<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>vctrs theory • vctrs</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="vctrs theory">
<meta property="og:description" content="">
<meta property="og:image" content="/logo.png">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">vctrs</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/s3-vector.html">S3 vectors</a>
    </li>
    <li>
      <a href="../articles/theory.html">vctrs theory</a>
    </li>
    <li>
      <a href="../articles/vctrs-vs-base.html">vctrs vs base</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/r-lib/vctrs">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>vctrs theory</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/r-lib/vctrs/blob/master/vignettes/theory.Rmd"><code>vignettes/theory.Rmd</code></a></small>
      <div class="hidden name"><code>theory.Rmd</code></div>

    </div>

    
    
<p>vctrs is heavily inspired by abstract and algebraic data types. The primary goal is not to provide new vector classes (although vctrs does provide a couple), but to think carefully about how existing classes should behave when used together.</p>
<p>This vignette collects together various thoughts related to theory; it’s not yet readable.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(vctrs)</a></code></pre></div>
<p>Julia: <a href="https://docs.julialang.org/en/latest/manual/conversion-and-promotion/#Promotion-1" class="uri">https://docs.julialang.org/en/latest/manual/conversion-and-promotion/#Promotion-1</a></p>
<div id="motivating-examples" class="section level2">
<h2 class="hasAnchor">
<a href="#motivating-examples" class="anchor"></a>Motivating examples</h2>
<p>There are two motivating examples from that illustrate many of the key ideas: <code>ifelse()</code> and <code>rbind()</code>. These have analogs in dplyr (<code>dplyr::if_else()</code> and <code>dplyr::bind_rows()</code>) which are slightly stricter on average than their base equivalents, but still adhoc.</p>
<p>What should the result of <code>ifelse()</code> look like? <code>ifelse()</code> has three inputs:</p>
<ul>
<li>a logical <code>condition</code>
</li>
<li>a value to use when the condition is <code>true</code>
</li>
<li>a value to use when the condition is <code>false</code>
</li>
</ul>
<p>It seems like these three inputs should all effect the output, but precisely how?</p>
<p><code>rbind()</code> poses two challenges. First, what should the overall output type be? i.e. if you combine a data frame and a tibble, what should the result be? What if you combine a data table and a tibble? Second, how should the individual columns be handled, and what should happen when the columns don’t match exactly between the inputs?</p>
<p><code>rbind()</code> also poses a challenge of recursion, because the columns of a data frame can themselves <a href="https://adv-r.hadley.nz/vectors-chap.html#matrix-and-data-frame-columns">be data frames</a>. This means that the type of a data frame is not flat</p>
</div>
<div id="algebra" class="section level2">
<h2 class="hasAnchor">
<a href="#algebra" class="anchor"></a>Algebra</h2>
<p><code><a href="../reference/vec_type2.html">vec_type2()</a></code> is a binary operator defined on the set of types. We will call the result of <code><a href="../reference/vec_type2.html">vec_type2(x, y)</a></code> the <strong>commmon type</strong> of <code>x</code> and <code>y</code>. The common type is only defined for a small set of pairs. If the common type does exist, we can say that <code>x</code> and <code>y</code> are uncoercable.</p>
<p>It has three useful properties:</p>
<ul>
<li>It is associative: <code>vec_type2(x, vec_type2(y, z)) == vec_type2(vec_type2(x, y), z)</code>
</li>
<li>It is commutative: <code>vec_type2(x, y) == vec_type2(y, x)</code>
</li>
<li>It has an identity element, <code>NULL</code>: <code>vec_type2(x, NULL) == x</code>
</li>
</ul>
<p>Together, this means the type system forms a <strong>commutative monoid</strong>, which has a couple of appealing properties:</p>
<ul>
<li><p>When have multiple types we can find their common type by progressively reducing (aka folding) <code><a href="../reference/vec_type2.html">vec_type2()</a></code>. We’ll get the same results regardless of whether we reduce from left or right.</p></li>
<li><p>The operation of finding common type is <a href="https://en.wikipedia.org/wiki/Prefix_sum#Parallel_algorithm">parallelisable</a>. For practial input size, parallelism is unlikely to helpful, but it’s nice property to have in general.</p></li>
</ul>
</div>
<div id="data-frames" class="section level2">
<h2 class="hasAnchor">
<a href="#data-frames" class="anchor"></a>Data frames</h2>
<p>Data frames are a <strong>product type</strong>: the type of the data frame is provided by the type of each column tagged with a name.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">df1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="ot">FALSE</span>, <span class="dt">y =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw"><a href="../reference/vec_ptype.html">vec_ptype</a></span>(df1)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">#&gt; prototype: data.frame&lt;</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co">#&gt;   x: logical</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">#&gt;   y: double</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">#&gt; &gt;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">df2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> 2L)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw"><a href="../reference/vec_ptype.html">vec_ptype</a></span>(df2)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="co">#&gt; prototype: data.frame&lt;</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co">#&gt;   x: double</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="co">#&gt;   y: integer</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="co">#&gt; &gt;</span></a></code></pre></div>
<p>The common type of two data frames is the common type of each pair of shared columns:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw"><a href="../reference/vec_ptype.html">vec_ptype</a></span>(df1, df2)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">#&gt; prototype: data.frame&lt;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">#&gt;   x: double</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">#&gt;   y: double</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">#&gt; &gt;</span></a></code></pre></div>
<p>By default, the common type of a data frame includes the union of columns in each data frame:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">df3 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">df4 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">z =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw"><a href="../reference/vec_ptype.html">vec_ptype</a></span>(df3, df4)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">#&gt; prototype: data.frame&lt;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co">#&gt;   x: double</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co">#&gt;   y: double</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="co">#&gt;   z: double</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="co">#&gt; &gt;</span></a></code></pre></div>
</div>
<div id="binned" class="section level2">
<h2 class="hasAnchor">
<a href="#binned" class="anchor"></a>Binned</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">new_binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, breaks) {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">stopifnot</span>(<span class="kw">is.double</span>(x))</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">structure</span>(x, <span class="dt">breaks =</span> breaks, <span class="dt">class =</span> <span class="st">"binned"</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="co">#' @export</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">format.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="kw">cat</span>(<span class="st">"&lt;binned&gt;</span><span class="ch">\n</span><span class="st">"</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  </a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  <span class="co"># Rely on factor printing as much as possible</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  f &lt;-<span class="st"> </span><span class="kw">cut</span>(x, <span class="kw">attr</span>(x, <span class="st">"breaks"</span>))</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  <span class="kw">print</span>(<span class="kw">as.integer</span>(f))</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  <span class="kw">cat</span>(<span class="st">"Bins: "</span>, <span class="kw">paste0</span>(<span class="kw">levels</span>(f), <span class="dt">collapse =</span> <span class="st">", "</span>), <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, <span class="dt">sep =</span> <span class="st">""</span>)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="kw">invisible</span>(x)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="co">#' @export</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20"><span class="st">`</span><span class="dt">[.binned</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, i, ...) {</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">  <span class="kw">new_binned</span>(<span class="kw">NextMethod</span>(), <span class="dt">breaks =</span> <span class="kw">attr</span>(x, <span class="st">"breaks"</span>))</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">}</a>
<a class="sourceLine" id="cb5-23" data-line-number="23"></a>
<a class="sourceLine" id="cb5-24" data-line-number="24">x &lt;-<span class="st"> </span><span class="kw">new_binned</span>(<span class="kw">runif</span>(<span class="dv">10</span>), <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">length =</span> <span class="dv">5</span>))</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">x</a>
<a class="sourceLine" id="cb5-26" data-line-number="26"><span class="co">#&gt;  [1] 0.2572418 0.8906484 0.3469014 0.9271877 0.7621041 0.6387973 0.8015855</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27"><span class="co">#&gt;  [8] 0.2787602 0.1418693 0.3663389</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"><span class="co">#&gt; attr(,"breaks")</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29"><span class="co">#&gt; [1] 0.00 0.25 0.50 0.75 1.00</span></a>
<a class="sourceLine" id="cb5-30" data-line-number="30"><span class="co">#&gt; attr(,"class")</span></a>
<a class="sourceLine" id="cb5-31" data-line-number="31"><span class="co">#&gt; [1] "binned"</span></a>
<a class="sourceLine" id="cb5-32" data-line-number="32"></a>
<a class="sourceLine" id="cb5-33" data-line-number="33">x[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb5-34" data-line-number="34"><span class="co">#&gt; [1] 0.2572418</span></a>
<a class="sourceLine" id="cb5-35" data-line-number="35"><span class="co">#&gt; attr(,"breaks")</span></a>
<a class="sourceLine" id="cb5-36" data-line-number="36"><span class="co">#&gt; [1] 0.00 0.25 0.50 0.75 1.00</span></a>
<a class="sourceLine" id="cb5-37" data-line-number="37"><span class="co">#&gt; attr(,"class")</span></a>
<a class="sourceLine" id="cb5-38" data-line-number="38"><span class="co">#&gt; [1] "binned"</span></a>
<a class="sourceLine" id="cb5-39" data-line-number="39"></a>
<a class="sourceLine" id="cb5-40" data-line-number="40">x[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb5-41" data-line-number="41"><span class="co">#&gt; numeric(0)</span></a>
<a class="sourceLine" id="cb5-42" data-line-number="42"><span class="co">#&gt; attr(,"breaks")</span></a>
<a class="sourceLine" id="cb5-43" data-line-number="43"><span class="co">#&gt; [1] 0.00 0.25 0.50 0.75 1.00</span></a>
<a class="sourceLine" id="cb5-44" data-line-number="44"><span class="co">#&gt; attr(,"class")</span></a>
<a class="sourceLine" id="cb5-45" data-line-number="45"><span class="co">#&gt; [1] "binned"</span></a></code></pre></div>
</div>
<div id="coercion" class="section level2">
<h2 class="hasAnchor">
<a href="#coercion" class="anchor"></a>Coercion</h2>
<p><code><a href="../reference/vec_type2.html">vec_type2()</a></code> defines the possible set of automatic (implicit) coercions. These coercions happen silently, so they should be quite strict; if they’re too flexible, they increase the chance of silently propagating mistakes. To think about what coercions your class should provide, it’s useful to look at coercions that vctrs provides for base types:</p>
<p><img src="../man/figures/coerce.png"><!-- --></p>
<p>If you squint your brain a little, I think you can see that each set of automatic coercions is about increasing resolution. Integers are low resolution versions of doubles, and dates are low resolution versions of date-times. Logicals are low resolution version of integers because there’s a strong convention that <code>TRUE</code> and <code>FALSE</code> can be used interchangeably with <code>1</code> and <code>0</code>.</p>
<p>But what is the resolution of a factor? We must take a somewhat pragmatic approach because base R often converts character vectors to factors, and we don’t want to be burdensome to users. So we say that a factor <code>x</code> has finer resolution than factor <code>y</code> if the levels of <code>y</code> are contained in <code>x</code>. So to find the common type of two factors, we take the union of the levels of both factors, resulting in a factor that has finer resolution than either. Finally, you can think of a character vector as a factor with every possible level, so factors and character vectors are coercible.</p>
<p>Using this reasoning, I think binned should only be coercible with doubles, as you can think of a double as a binned vector with inifinitely small bins. I expect that most custom classes will be coercible to zero or one base classes.</p>
<div id="double-dispatch" class="section level3">
<h3 class="hasAnchor">
<a href="#double-dispatch" class="anchor"></a>Double dispatch</h3>
<p>The implementation of <code><a href="../reference/vec_type2.html">vec_type2()</a></code> relies on <strong><a href="https://en.wikipedia.org/wiki/Double_dispatch">double dispatch</a></strong>, because the result depends on the type of both arguments. S3 does not natively support double dispatch, but we can implement with a trick: doing single dispatch twice.</p>
<p>It looks like this: <code><a href="../reference/vec_type2.html">vec_type2()</a></code> is a generic funtion, and the method it calls is <em>also</em> a generic:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">vec_type2 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">UseMethod</span>(<span class="st">"vec_type2"</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">vec_type2.integer &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">UseMethod</span>(<span class="st">"vec_type2.integer"</span>, y)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">vec_type2.integer.double &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">double</span>()</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">}</a></code></pre></div>
<p>To make this a bit more concrete, when you call <code><a href="../reference/vec_type2.html">vec_type2(1L, 1)</a></code> the sequence of calls is:</p>
<ul>
<li><code><a href="../reference/vec_type2.html">vec_type2()</a></code></li>
<li><code><a href="../reference/vec_type2.html">vec_type2.integer()</a></code></li>
<li><code>vec_type2.integer.double()</code></li>
</ul>
<p>If you call <code><a href="../reference/vec_type2.html">vec_type2(1, 1L)</a></code> the sequence of calls is quite different:</p>
<ul>
<li><code><a href="../reference/vec_type2.html">vec_type2()</a></code></li>
<li><code><a href="../reference/vec_type2.html">vec_type2.double()</a></code></li>
<li><code>vec_type2.double.integer()</code></li>
</ul>
<p>In order to preserve commutativity, <code>vec_type2.x.y()</code> <strong>must</strong> return the same value as <code>vec_type2.y.x()</code>. Unfortunately there’s no way to enforce this at the language level, so instead we use strong conventions (always defining the pair of methods next to each other) and unit tests to make sure that we’re consistent.</p>
</div>
<div id="extending-binned" class="section level3">
<h3 class="hasAnchor">
<a href="#extending-binned" class="anchor"></a>Extending binned</h3>
<p>Now that you understand the principles governing which coercions should exist, and the basic idea behind the implementation of <code><a href="../reference/vec_type2.html">vec_type2()</a></code>, we can implement coercions for the binned class.</p>
<p>First, we create <code>vec_type2.binned()</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">vec_type2.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="kw">UseMethod</span>(<span class="st">"vec_type2.binned"</span>, y)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">} </a></code></pre></div>
<p>(We’ll come back to how to manage this in your package <code>NAMESPACE</code> later.)</p>
<p>Next, we add two required methods to <code>vec_type2.binned()</code>:</p>
<ul>
<li>
<p>A <code>unknown</code> method must return a vector of the same type as <code>x</code>, but with zero length. This makes <code><a href="../reference/unknown.html">unknown()</a></code> is the identity element of the type system,an important algebraic property.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">vec_type2.binned.unknown &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  x[0L]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">}</a></code></pre></div>
</li>
<li>
<p>A default method must throw an informative error if there is no common type. vctrs provides the <code><a href="../reference/vctrs-conditions.html">stop_incompatible_type()</a></code> helper. This gives a standard error message and uses a <a href="https://adv-r.hadley.nz/conditions.html#custom-conditions">custom condition</a> to make testing more robust (e.g. <code>expect_error(class = "error_incompatible_type")</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">vec_type2.binned.default &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw"><a href="../reference/vctrs-conditions.html">stop_incompatible_type</a></span>(x, y)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">}</a></code></pre></div>
</li>
</ul>
<p>Now we can provide the meat of our implementation, ensuring that the common type of double and binned is double. We need a pair of methods for the two possible orders of the argument.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">vec_type2.binned.double &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) <span class="kw">double</span>()</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">vec_type2.double.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) <span class="kw">double</span>()</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw"><a href="../reference/vec_type2.html">vec_type2</a></span>(x, <span class="fl">1.5</span>)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">#&gt; numeric(0)</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw"><a href="../reference/vec_type2.html">vec_type2</a></span>(<span class="fl">1.5</span>, x)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">#&gt; numeric(0)</span></a></code></pre></div>
<p>We also need to handle the binned &lt;-&gt; binned case. We take the same approach as for factors, taking the union of the breaks.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">union_breaks &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  x_breaks &lt;-<span class="st"> </span><span class="kw">attr</span>(x, <span class="st">"breaks"</span>)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  y_breaks &lt;-<span class="st"> </span><span class="kw">attr</span>(y, <span class="st">"breaks"</span>)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="kw">sort</span>(<span class="kw">union</span>(x_breaks, y_breaks))</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">vec_type2.binned.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="kw">new_binned</span>(<span class="kw">double</span>(), <span class="dt">breaks =</span> <span class="kw">union_breaks</span>(x, y))</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">y &lt;-<span class="st"> </span><span class="kw">new_binned</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>), <span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">2.5</span>, <span class="dv">5</span>, <span class="fl">7.5</span>))</a>
<a class="sourceLine" id="cb11-13" data-line-number="13"><span class="kw"><a href="../reference/vec_type2.html">vec_type2</a></span>(x, y)</a>
<a class="sourceLine" id="cb11-14" data-line-number="14"><span class="co">#&gt; numeric(0)</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="co">#&gt; attr(,"breaks")</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16"><span class="co">#&gt; [1] 0.00 0.25 0.50 0.75 1.00 2.50 5.00 7.50</span></a>
<a class="sourceLine" id="cb11-17" data-line-number="17"><span class="co">#&gt; attr(,"class")</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="co">#&gt; [1] "binned"</span></a></code></pre></div>
</div>
</div>
<div id="casting" class="section level2">
<h2 class="hasAnchor">
<a href="#casting" class="anchor"></a>Casting</h2>
<p><code><a href="../reference/vec_cast.html">vec_cast()</a></code> defines the possible set user-requested coercions, known as <strong>casts</strong>. Because these are user initiated, the set of possible casts is much larger than the set of possible coercions. The following diagram shows the set of casts that vctrs provides for base classes. If you can follow arrows in the same direction from one class to another, then a cast exists.</p>
<p><img src="../man/figures/cast.png"><!-- --></p>
<p>Note that the arrows are bidirectional: if you can cast from <code>x</code> to <code>y</code>, you should also be able to cast back from <code>y</code> to <code>x</code>.</p>
<p>If type <code>x</code> has greater resolution than <code>y</code>, there will be some inputs that lose precision. These should generate warnings using <code><a href="../reference/vctrs-conditions.html">warn_lossy_cast()</a></code>. You can see that in action when casting from doubles to integers; only some doubles can become integers without losing resolution.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw"><a href="../reference/vec_cast.html">vec_cast</a></span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">10</span>), <span class="dt">to =</span> <span class="kw">integer</span>())</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co">#&gt; [1]  1  2 10</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="kw"><a href="../reference/vec_cast.html">vec_cast</a></span>(<span class="kw">c</span>(<span class="fl">1.5</span>, <span class="dv">2</span>, <span class="fl">10.5</span>), <span class="dt">to =</span> <span class="kw">integer</span>())</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co">#&gt; Warning: Lossy cast from double to integer</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">#&gt; Locations: 1, 3</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="co">#&gt; [1]  1  2 10</span></a></code></pre></div>
<p>Generally, you should provide a cast method whenever it’s meaningful to cast back and forth from a given type. For binned vectors, I think this is only true for doubles and lists.</p>
<div id="extending-binned-1" class="section level3">
<h3 class="hasAnchor">
<a href="#extending-binned-1" class="anchor"></a>Extending binned</h3>
<p>Like <code><a href="../reference/vec_type2.html">vec_type2()</a></code>, <code><a href="../reference/vec_cast.html">vec_cast()</a></code> uses double dispatch, so the initial steps are similar. We start by creating the method/generic, and providing <code>NULL</code> and <code>default</code> methods. You can copy and paste these functions as they must always be the same.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">vec_cast.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">UseMethod</span>(<span class="st">"vec_cast.binned"</span>)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">vec_cast.binned.unknown &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) {</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  <span class="ot">NULL</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">vec_cast.binned.default &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) {</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  <span class="kw"><a href="../reference/vctrs-conditions.html">stop_incompatible_cast</a></span>(x, to)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">}</a></code></pre></div>
<p>Note that the order of dispatch is different to <code><a href="../reference/vec_type2.html">vec_type2()</a></code>. Here the second argument, <code>to</code>, forms the first component of the function name, i.e. <code>vec_cast.binned.NULL()</code> casts a <code>NULL</code> vector to <code>binned</code>. This might be a bit confusing, but makes sense if you think about <code>as.integer()</code>, <code>as.double()</code> etc.</p>
<p>There is one extra method that you should always provide for <code><a href="../reference/vec_cast.html">vec_cast()</a></code>: the ability to round trip to and from a list. To cast your vector to a list, implement an <code>as.list()</code> method, which can always follow the simple form show below. To cast from a list back to your class, use the <code><a href="../reference/vec_list_cast.html">vec_list_cast()</a></code> helper provided by vctrs.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">as.list.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">lapply</span>(<span class="kw">seq_along</span>(x), <span class="cf">function</span>(i) x[i])</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">vec_cast.list.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) <span class="kw">as.list</span>(x)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">vec_cast.binned.list &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) <span class="kw">cast_from_list</span>(x, to)</a></code></pre></div>
<p>You also need to make sure that your object can cast to itself:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">vec_cast.binned.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">new_binned</span>(<span class="kw">as.vector</span>(x), <span class="dt">breaks =</span> <span class="kw">attr</span>(x, <span class="st">"breaks"</span>))</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">}</a></code></pre></div>
<p>This case should probably generate some warnings, but I couldn’t figure out what the principle should be.</p>
<p>Finish up your <code><a href="../reference/vec_cast.html">vec_cast()</a></code> method by providing any other casts. For binned, we need to describe how to cast from binned to double and double to binned:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">vec_cast.binned.double &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) {</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="co"># using as.vector() for its purpose of stripping attributes</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">as.vector</span>(x)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">vec_cast.double.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) {</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  <span class="kw">new_binned</span>(x, <span class="dt">breaks =</span> <span class="kw">attr</span>(to, <span class="st">"breaks"</span>))</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">}</a></code></pre></div>
<p>You can then confirm that <code><a href="../reference/vec_type2.html">vec_type2()</a></code> and <code><a href="../reference/vec_cast.html">vec_cast()</a></code> are plumbed together correctly by using <code><a href="../reference/vec_c.html">vec_c()</a></code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw"><a href="../reference/vec_c.html">vec_c</a></span>(x[<span class="dv">1</span>], <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="co">#&gt; [1] 0.2572418 0.5000000</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw"><a href="../reference/vec_c.html">vec_c</a></span>(<span class="fl">0.5</span>, <span class="dt">.ptype =</span> x)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="co">#&gt; [1] 0.5</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="co">#&gt; attr(,"breaks")</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="co">#&gt; [1] 0.00 0.25 0.50 0.75 1.00</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="co">#&gt; attr(,"class")</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"><span class="co">#&gt; [1] "binned"</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"></a>
<a class="sourceLine" id="cb17-11" data-line-number="11"><span class="kw"><a href="../reference/vec_c.html">vec_c</a></span>(x[<span class="dv">1</span>], <span class="fl">0.5</span>, <span class="dt">.ptype =</span> x)</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"><span class="co">#&gt; [1] 0.2572418 0.5000000</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13"><span class="co">#&gt; attr(,"breaks")</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14"><span class="co">#&gt; [1] 0.00 0.25 0.50 0.75 1.00</span></a>
<a class="sourceLine" id="cb17-15" data-line-number="15"><span class="co">#&gt; attr(,"class")</span></a>
<a class="sourceLine" id="cb17-16" data-line-number="16"><span class="co">#&gt; [1] "binned"</span></a></code></pre></div>
</div>
</div>
<div id="namespaces" class="section level2">
<h2 class="hasAnchor">
<a href="#namespaces" class="anchor"></a>Namespaces</h2>
<p>Defining S3 method interactively is fine for iteration and exploration, but if your vector lives in a package, you also need to register the S3 methods by listing them in the <code>NAMESPACE</code> file. The namespace declarations are a little tricky because (e.g.) <code>vec_cast.binned()</code> is both a generic function (which must be exported with <code>export()</code>) and an S3 method (which must be registered with <code>S3method()</code>).</p>
<p>This problem wasn’t considered in the design of roxygen2, so you have to be quite explicit:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">#' @export</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co">#' @method vec_cast binned</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="co">#' @export vec_cast.binned</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">vec_cast.binned &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">} </a></code></pre></div>
<p>You also need to register the individual double-dispatch methods. Unfortuantely roxygen’s heuristic for determing the name of the generic from the name of the method gives the wrong result here, so you need to fully specify it:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">#' @method vec_cast.binned double</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="co">#' @export</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">vec_cast.binned.double &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">}</a></code></pre></div>
<p>Hopefully future versions of roxygen will make these exports less painful.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#motivating-examples">Motivating examples</a></li>
      <li><a href="#algebra">Algebra</a></li>
      <li><a href="#data-frames">Data frames</a></li>
      <li><a href="#binned">Binned</a></li>
      <li><a href="#coercion">Coercion</a></li>
      <li><a href="#casting">Casting</a></li>
      <li><a href="#namespaces">Namespaces</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by <a href="http://hadley.nz">Hadley Wickham</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
